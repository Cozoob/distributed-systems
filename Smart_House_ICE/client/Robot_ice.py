# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.9
#
# <auto-generated>
#
# Generated from file `Robot.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module SmartHouse
_M_SmartHouse = Ice.openModule('SmartHouse')
__name__ = 'SmartHouse'

if 'TimeOfDay' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.TimeOfDay = Ice.createTempClass()
    class TimeOfDay(object):
        def __init__(self, hour=0, minute=0, second=0):
            self.hour = hour
            self.minute = minute
            self.second = second

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.hour)
            _h = 5 * _h + Ice.getHash(self.minute)
            _h = 5 * _h + Ice.getHash(self.second)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHouse.TimeOfDay):
                return NotImplemented
            else:
                if self.hour is None or other.hour is None:
                    if self.hour != other.hour:
                        return (-1 if self.hour is None else 1)
                else:
                    if self.hour < other.hour:
                        return -1
                    elif self.hour > other.hour:
                        return 1
                if self.minute is None or other.minute is None:
                    if self.minute != other.minute:
                        return (-1 if self.minute is None else 1)
                else:
                    if self.minute < other.minute:
                        return -1
                    elif self.minute > other.minute:
                        return 1
                if self.second is None or other.second is None:
                    if self.second != other.second:
                        return (-1 if self.second is None else 1)
                else:
                    if self.second < other.second:
                        return -1
                    elif self.second > other.second:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_TimeOfDay)

        __repr__ = __str__

    _M_SmartHouse._t_TimeOfDay = IcePy.defineStruct('::SmartHouse::TimeOfDay', TimeOfDay, (), (
        ('hour', (), IcePy._t_short),
        ('minute', (), IcePy._t_short),
        ('second', (), IcePy._t_short)
    ))

    _M_SmartHouse.TimeOfDay = TimeOfDay
    del TimeOfDay

if 'OutOfEnergyException' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.OutOfEnergyException = Ice.createTempClass()
    class OutOfEnergyException(Ice.UserException):
        def __init__(self, errorTime=Ice._struct_marker, message="Cannot perform movement - robot does not have enough energy."):
            if errorTime is Ice._struct_marker:
                self.errorTime = _M_SmartHouse.TimeOfDay()
            else:
                self.errorTime = errorTime
            self.message = message

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::OutOfEnergyException'

    _M_SmartHouse._t_OutOfEnergyException = IcePy.defineException('::SmartHouse::OutOfEnergyException', OutOfEnergyException, (), False, None, (
        ('errorTime', (), _M_SmartHouse._t_TimeOfDay, False, 0),
        ('message', (), IcePy._t_string, True, 1)
    ))
    OutOfEnergyException._ice_type = _M_SmartHouse._t_OutOfEnergyException

    _M_SmartHouse.OutOfEnergyException = OutOfEnergyException
    del OutOfEnergyException

if 'InvalidPositionException' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.InvalidPositionException = Ice.createTempClass()
    class InvalidPositionException(Ice.UserException):
        def __init__(self, errorTime=Ice._struct_marker, message="Cannot set new position - invalid position value."):
            if errorTime is Ice._struct_marker:
                self.errorTime = _M_SmartHouse.TimeOfDay()
            else:
                self.errorTime = errorTime
            self.message = message

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::InvalidPositionException'

    _M_SmartHouse._t_InvalidPositionException = IcePy.defineException('::SmartHouse::InvalidPositionException', InvalidPositionException, (), False, None, (
        ('errorTime', (), _M_SmartHouse._t_TimeOfDay, False, 0),
        ('message', (), IcePy._t_string, True, 2)
    ))
    InvalidPositionException._ice_type = _M_SmartHouse._t_InvalidPositionException

    _M_SmartHouse.InvalidPositionException = InvalidPositionException
    del InvalidPositionException

if 'RobotNotActiveException' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.RobotNotActiveException = Ice.createTempClass()
    class RobotNotActiveException(Ice.UserException):
        def __init__(self, errorTime=Ice._struct_marker, message="Cannot perform action - robot is not active."):
            if errorTime is Ice._struct_marker:
                self.errorTime = _M_SmartHouse.TimeOfDay()
            else:
                self.errorTime = errorTime
            self.message = message

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::RobotNotActiveException'

    _M_SmartHouse._t_RobotNotActiveException = IcePy.defineException('::SmartHouse::RobotNotActiveException', RobotNotActiveException, (), False, None, (
        ('errorTime', (), _M_SmartHouse._t_TimeOfDay, False, 0),
        ('message', (), IcePy._t_string, True, 3)
    ))
    RobotNotActiveException._ice_type = _M_SmartHouse._t_RobotNotActiveException

    _M_SmartHouse.RobotNotActiveException = RobotNotActiveException
    del RobotNotActiveException

if 'RobotAlreadyActiveException' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.RobotAlreadyActiveException = Ice.createTempClass()
    class RobotAlreadyActiveException(Ice.UserException):
        def __init__(self, errorTime=Ice._struct_marker, message="Cannot activate robot - robot is already active."):
            if errorTime is Ice._struct_marker:
                self.errorTime = _M_SmartHouse.TimeOfDay()
            else:
                self.errorTime = errorTime
            self.message = message

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::RobotAlreadyActiveException'

    _M_SmartHouse._t_RobotAlreadyActiveException = IcePy.defineException('::SmartHouse::RobotAlreadyActiveException', RobotAlreadyActiveException, (), False, None, (
        ('errorTime', (), _M_SmartHouse._t_TimeOfDay, False, 0),
        ('message', (), IcePy._t_string, True, 4)
    ))
    RobotAlreadyActiveException._ice_type = _M_SmartHouse._t_RobotAlreadyActiveException

    _M_SmartHouse.RobotAlreadyActiveException = RobotAlreadyActiveException
    del RobotAlreadyActiveException

if 'Movement' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.Movement = Ice.createTempClass()
    class Movement(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Movement.UP = Movement("UP", 0)
    Movement.DOWN = Movement("DOWN", 1)
    Movement.LEFT = Movement("LEFT", 2)
    Movement.RIGHT = Movement("RIGHT", 3)
    Movement._enumerators = { 0:Movement.UP, 1:Movement.DOWN, 2:Movement.LEFT, 3:Movement.RIGHT }

    _M_SmartHouse._t_Movement = IcePy.defineEnum('::SmartHouse::Movement', Movement, (), Movement._enumerators)

    _M_SmartHouse.Movement = Movement
    del Movement

if 'Position' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.Position = Ice.createTempClass()
    class Position(object):
        def __init__(self, x=0.0, y=0.0):
            self.x = x
            self.y = y

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_SmartHouse.Position):
                return NotImplemented
            else:
                if self.x != other.x:
                    return False
                if self.y != other.y:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_Position)

        __repr__ = __str__

    _M_SmartHouse._t_Position = IcePy.defineStruct('::SmartHouse::Position', Position, (), (
        ('x', (), IcePy._t_float),
        ('y', (), IcePy._t_float)
    ))

    _M_SmartHouse.Position = Position
    del Position

_M_SmartHouse._t_Robot = IcePy.defineValue('::SmartHouse::Robot', Ice.Value, -1, (), False, True, None, ())

if 'RobotPrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.RobotPrx = Ice.createTempClass()
    class RobotPrx(Ice.ObjectPrx):

        def isActive(self, context=None):
            return _M_SmartHouse.Robot._op_isActive.invoke(self, ((), context))

        def isActiveAsync(self, context=None):
            return _M_SmartHouse.Robot._op_isActive.invokeAsync(self, ((), context))

        def begin_isActive(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Robot._op_isActive.begin(self, ((), _response, _ex, _sent, context))

        def end_isActive(self, _r):
            return _M_SmartHouse.Robot._op_isActive.end(self, _r)

        def getEnergy(self, context=None):
            return _M_SmartHouse.Robot._op_getEnergy.invoke(self, ((), context))

        def getEnergyAsync(self, context=None):
            return _M_SmartHouse.Robot._op_getEnergy.invokeAsync(self, ((), context))

        def begin_getEnergy(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Robot._op_getEnergy.begin(self, ((), _response, _ex, _sent, context))

        def end_getEnergy(self, _r):
            return _M_SmartHouse.Robot._op_getEnergy.end(self, _r)

        def getPositionX(self, context=None):
            return _M_SmartHouse.Robot._op_getPositionX.invoke(self, ((), context))

        def getPositionXAsync(self, context=None):
            return _M_SmartHouse.Robot._op_getPositionX.invokeAsync(self, ((), context))

        def begin_getPositionX(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Robot._op_getPositionX.begin(self, ((), _response, _ex, _sent, context))

        def end_getPositionX(self, _r):
            return _M_SmartHouse.Robot._op_getPositionX.end(self, _r)

        def getPositionY(self, context=None):
            return _M_SmartHouse.Robot._op_getPositionY.invoke(self, ((), context))

        def getPositionYAsync(self, context=None):
            return _M_SmartHouse.Robot._op_getPositionY.invokeAsync(self, ((), context))

        def begin_getPositionY(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Robot._op_getPositionY.begin(self, ((), _response, _ex, _sent, context))

        def end_getPositionY(self, _r):
            return _M_SmartHouse.Robot._op_getPositionY.end(self, _r)

        def move(self, m, context=None):
            return _M_SmartHouse.Robot._op_move.invoke(self, ((m, ), context))

        def moveAsync(self, m, context=None):
            return _M_SmartHouse.Robot._op_move.invokeAsync(self, ((m, ), context))

        def begin_move(self, m, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Robot._op_move.begin(self, ((m, ), _response, _ex, _sent, context))

        def end_move(self, _r):
            return _M_SmartHouse.Robot._op_move.end(self, _r)

        def setNewPosition(self, p, context=None):
            return _M_SmartHouse.Robot._op_setNewPosition.invoke(self, ((p, ), context))

        def setNewPositionAsync(self, p, context=None):
            return _M_SmartHouse.Robot._op_setNewPosition.invokeAsync(self, ((p, ), context))

        def begin_setNewPosition(self, p, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Robot._op_setNewPosition.begin(self, ((p, ), _response, _ex, _sent, context))

        def end_setNewPosition(self, _r):
            return _M_SmartHouse.Robot._op_setNewPosition.end(self, _r)

        def turnOff(self, context=None):
            return _M_SmartHouse.Robot._op_turnOff.invoke(self, ((), context))

        def turnOffAsync(self, context=None):
            return _M_SmartHouse.Robot._op_turnOff.invokeAsync(self, ((), context))

        def begin_turnOff(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Robot._op_turnOff.begin(self, ((), _response, _ex, _sent, context))

        def end_turnOff(self, _r):
            return _M_SmartHouse.Robot._op_turnOff.end(self, _r)

        def turnOn(self, context=None):
            return _M_SmartHouse.Robot._op_turnOn.invoke(self, ((), context))

        def turnOnAsync(self, context=None):
            return _M_SmartHouse.Robot._op_turnOn.invokeAsync(self, ((), context))

        def begin_turnOn(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Robot._op_turnOn.begin(self, ((), _response, _ex, _sent, context))

        def end_turnOn(self, _r):
            return _M_SmartHouse.Robot._op_turnOn.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.RobotPrx.ice_checkedCast(proxy, '::SmartHouse::Robot', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.RobotPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::Robot'
    _M_SmartHouse._t_RobotPrx = IcePy.defineProxy('::SmartHouse::Robot', RobotPrx)

    _M_SmartHouse.RobotPrx = RobotPrx
    del RobotPrx

    _M_SmartHouse.Robot = Ice.createTempClass()
    class Robot(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::Robot')

        def ice_id(self, current=None):
            return '::SmartHouse::Robot'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::Robot'

        def isActive(self, current=None):
            raise NotImplementedError("servant method 'isActive' not implemented")

        def getEnergy(self, current=None):
            raise NotImplementedError("servant method 'getEnergy' not implemented")

        def getPositionX(self, current=None):
            raise NotImplementedError("servant method 'getPositionX' not implemented")

        def getPositionY(self, current=None):
            raise NotImplementedError("servant method 'getPositionY' not implemented")

        def move(self, m, current=None):
            raise NotImplementedError("servant method 'move' not implemented")

        def setNewPosition(self, p, current=None):
            raise NotImplementedError("servant method 'setNewPosition' not implemented")

        def turnOff(self, current=None):
            raise NotImplementedError("servant method 'turnOff' not implemented")

        def turnOn(self, current=None):
            raise NotImplementedError("servant method 'turnOn' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_RobotDisp)

        __repr__ = __str__

    _M_SmartHouse._t_RobotDisp = IcePy.defineClass('::SmartHouse::Robot', Robot, (), None, ())
    Robot._ice_type = _M_SmartHouse._t_RobotDisp

    Robot._op_isActive = IcePy.Operation('isActive', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), ())
    Robot._op_getEnergy = IcePy.Operation('getEnergy', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_byte, False, 0), ())
    Robot._op_getPositionX = IcePy.Operation('getPositionX', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_float, False, 0), ())
    Robot._op_getPositionY = IcePy.Operation('getPositionY', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_float, False, 0), ())
    Robot._op_move = IcePy.Operation('move', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHouse._t_Movement, False, 0),), (), None, (_M_SmartHouse._t_OutOfEnergyException, _M_SmartHouse._t_InvalidPositionException, _M_SmartHouse._t_RobotNotActiveException))
    Robot._op_setNewPosition = IcePy.Operation('setNewPosition', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHouse._t_Position, False, 0),), (), None, (_M_SmartHouse._t_InvalidPositionException, _M_SmartHouse._t_RobotNotActiveException))
    Robot._op_turnOff = IcePy.Operation('turnOff', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Robot._op_turnOn = IcePy.Operation('turnOn', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_SmartHouse.Robot = Robot
    del Robot

_M_SmartHouse._t_Sensor = IcePy.defineValue('::SmartHouse::Sensor', Ice.Value, -1, (), False, True, None, ())

if 'SensorPrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.SensorPrx = Ice.createTempClass()
    class SensorPrx(Ice.ObjectPrx):

        def getName(self, context=None):
            return _M_SmartHouse.Sensor._op_getName.invoke(self, ((), context))

        def getNameAsync(self, context=None):
            return _M_SmartHouse.Sensor._op_getName.invokeAsync(self, ((), context))

        def begin_getName(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Sensor._op_getName.begin(self, ((), _response, _ex, _sent, context))

        def end_getName(self, _r):
            return _M_SmartHouse.Sensor._op_getName.end(self, _r)

        def getType(self, context=None):
            return _M_SmartHouse.Sensor._op_getType.invoke(self, ((), context))

        def getTypeAsync(self, context=None):
            return _M_SmartHouse.Sensor._op_getType.invokeAsync(self, ((), context))

        def begin_getType(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Sensor._op_getType.begin(self, ((), _response, _ex, _sent, context))

        def end_getType(self, _r):
            return _M_SmartHouse.Sensor._op_getType.end(self, _r)

        def setCurrentTime(self, context=None):
            return _M_SmartHouse.Sensor._op_setCurrentTime.invoke(self, ((), context))

        def setCurrentTimeAsync(self, context=None):
            return _M_SmartHouse.Sensor._op_setCurrentTime.invokeAsync(self, ((), context))

        def begin_setCurrentTime(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Sensor._op_setCurrentTime.begin(self, ((), _response, _ex, _sent, context))

        def end_setCurrentTime(self, _r):
            return _M_SmartHouse.Sensor._op_setCurrentTime.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.SensorPrx.ice_checkedCast(proxy, '::SmartHouse::Sensor', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.SensorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::Sensor'
    _M_SmartHouse._t_SensorPrx = IcePy.defineProxy('::SmartHouse::Sensor', SensorPrx)

    _M_SmartHouse.SensorPrx = SensorPrx
    del SensorPrx

    _M_SmartHouse.Sensor = Ice.createTempClass()
    class Sensor(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::Sensor')

        def ice_id(self, current=None):
            return '::SmartHouse::Sensor'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::Sensor'

        def getName(self, current=None):
            raise NotImplementedError("servant method 'getName' not implemented")

        def getType(self, current=None):
            raise NotImplementedError("servant method 'getType' not implemented")

        def setCurrentTime(self, current=None):
            raise NotImplementedError("servant method 'setCurrentTime' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_SensorDisp)

        __repr__ = __str__

    _M_SmartHouse._t_SensorDisp = IcePy.defineClass('::SmartHouse::Sensor', Sensor, (), None, ())
    Sensor._ice_type = _M_SmartHouse._t_SensorDisp

    Sensor._op_getName = IcePy.Operation('getName', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    Sensor._op_getType = IcePy.Operation('getType', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())
    Sensor._op_setCurrentTime = IcePy.Operation('setCurrentTime', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_SmartHouse.Sensor = Sensor
    del Sensor

if 'GasSensorException' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.GasSensorException = Ice.createTempClass()
    class GasSensorException(Ice.UserException):
        def __init__(self, errorTime=Ice._struct_marker, reason=''):
            if errorTime is Ice._struct_marker:
                self.errorTime = _M_SmartHouse.TimeOfDay()
            else:
                self.errorTime = errorTime
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::GasSensorException'

    _M_SmartHouse._t_GasSensorException = IcePy.defineException('::SmartHouse::GasSensorException', GasSensorException, (), False, None, (
        ('errorTime', (), _M_SmartHouse._t_TimeOfDay, False, 0),
        ('reason', (), IcePy._t_string, False, 0)
    ))
    GasSensorException._ice_type = _M_SmartHouse._t_GasSensorException

    _M_SmartHouse.GasSensorException = GasSensorException
    del GasSensorException

_M_SmartHouse._t_GasSensor = IcePy.defineValue('::SmartHouse::GasSensor', Ice.Value, -1, (), False, True, None, ())

if 'GasSensorPrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.GasSensorPrx = Ice.createTempClass()
    class GasSensorPrx(_M_SmartHouse.SensorPrx):

        def gasDetected(self, level, context=None):
            return _M_SmartHouse.GasSensor._op_gasDetected.invoke(self, ((level, ), context))

        def gasDetectedAsync(self, level, context=None):
            return _M_SmartHouse.GasSensor._op_gasDetected.invokeAsync(self, ((level, ), context))

        def begin_gasDetected(self, level, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.GasSensor._op_gasDetected.begin(self, ((level, ), _response, _ex, _sent, context))

        def end_gasDetected(self, _r):
            return _M_SmartHouse.GasSensor._op_gasDetected.end(self, _r)

        def getGasLevel(self, context=None):
            return _M_SmartHouse.GasSensor._op_getGasLevel.invoke(self, ((), context))

        def getGasLevelAsync(self, context=None):
            return _M_SmartHouse.GasSensor._op_getGasLevel.invokeAsync(self, ((), context))

        def begin_getGasLevel(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.GasSensor._op_getGasLevel.begin(self, ((), _response, _ex, _sent, context))

        def end_getGasLevel(self, _r):
            return _M_SmartHouse.GasSensor._op_getGasLevel.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.GasSensorPrx.ice_checkedCast(proxy, '::SmartHouse::GasSensor', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.GasSensorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::GasSensor'
    _M_SmartHouse._t_GasSensorPrx = IcePy.defineProxy('::SmartHouse::GasSensor', GasSensorPrx)

    _M_SmartHouse.GasSensorPrx = GasSensorPrx
    del GasSensorPrx

    _M_SmartHouse.GasSensor = Ice.createTempClass()
    class GasSensor(_M_SmartHouse.Sensor):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::GasSensor', '::SmartHouse::Sensor')

        def ice_id(self, current=None):
            return '::SmartHouse::GasSensor'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::GasSensor'

        def gasDetected(self, level, current=None):
            raise NotImplementedError("servant method 'gasDetected' not implemented")

        def getGasLevel(self, current=None):
            raise NotImplementedError("servant method 'getGasLevel' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_GasSensorDisp)

        __repr__ = __str__

    _M_SmartHouse._t_GasSensorDisp = IcePy.defineClass('::SmartHouse::GasSensor', GasSensor, (), None, (_M_SmartHouse._t_SensorDisp,))
    GasSensor._ice_type = _M_SmartHouse._t_GasSensorDisp

    GasSensor._op_gasDetected = IcePy.Operation('gasDetected', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0),), (), None, (_M_SmartHouse._t_GasSensorException,))
    GasSensor._op_getGasLevel = IcePy.Operation('getGasLevel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_double, False, 0), ())

    _M_SmartHouse.GasSensor = GasSensor
    del GasSensor

if 'TemperatureSensorException' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.TemperatureSensorException = Ice.createTempClass()
    class TemperatureSensorException(Ice.UserException):
        def __init__(self, errorTime=Ice._struct_marker, reason=''):
            if errorTime is Ice._struct_marker:
                self.errorTime = _M_SmartHouse.TimeOfDay()
            else:
                self.errorTime = errorTime
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::TemperatureSensorException'

    _M_SmartHouse._t_TemperatureSensorException = IcePy.defineException('::SmartHouse::TemperatureSensorException', TemperatureSensorException, (), False, None, (
        ('errorTime', (), _M_SmartHouse._t_TimeOfDay, False, 0),
        ('reason', (), IcePy._t_string, False, 0)
    ))
    TemperatureSensorException._ice_type = _M_SmartHouse._t_TemperatureSensorException

    _M_SmartHouse.TemperatureSensorException = TemperatureSensorException
    del TemperatureSensorException

_M_SmartHouse._t_TemperatureSensor = IcePy.defineValue('::SmartHouse::TemperatureSensor', Ice.Value, -1, (), False, True, None, ())

if 'TemperatureSensorPrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.TemperatureSensorPrx = Ice.createTempClass()
    class TemperatureSensorPrx(_M_SmartHouse.SensorPrx):

        def temperatureChanged(self, temperature, context=None):
            return _M_SmartHouse.TemperatureSensor._op_temperatureChanged.invoke(self, ((temperature, ), context))

        def temperatureChangedAsync(self, temperature, context=None):
            return _M_SmartHouse.TemperatureSensor._op_temperatureChanged.invokeAsync(self, ((temperature, ), context))

        def begin_temperatureChanged(self, temperature, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.TemperatureSensor._op_temperatureChanged.begin(self, ((temperature, ), _response, _ex, _sent, context))

        def end_temperatureChanged(self, _r):
            return _M_SmartHouse.TemperatureSensor._op_temperatureChanged.end(self, _r)

        def getTemperature(self, context=None):
            return _M_SmartHouse.TemperatureSensor._op_getTemperature.invoke(self, ((), context))

        def getTemperatureAsync(self, context=None):
            return _M_SmartHouse.TemperatureSensor._op_getTemperature.invokeAsync(self, ((), context))

        def begin_getTemperature(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.TemperatureSensor._op_getTemperature.begin(self, ((), _response, _ex, _sent, context))

        def end_getTemperature(self, _r):
            return _M_SmartHouse.TemperatureSensor._op_getTemperature.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.TemperatureSensorPrx.ice_checkedCast(proxy, '::SmartHouse::TemperatureSensor', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.TemperatureSensorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::TemperatureSensor'
    _M_SmartHouse._t_TemperatureSensorPrx = IcePy.defineProxy('::SmartHouse::TemperatureSensor', TemperatureSensorPrx)

    _M_SmartHouse.TemperatureSensorPrx = TemperatureSensorPrx
    del TemperatureSensorPrx

    _M_SmartHouse.TemperatureSensor = Ice.createTempClass()
    class TemperatureSensor(_M_SmartHouse.Sensor):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::Sensor', '::SmartHouse::TemperatureSensor')

        def ice_id(self, current=None):
            return '::SmartHouse::TemperatureSensor'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::TemperatureSensor'

        def temperatureChanged(self, temperature, current=None):
            raise NotImplementedError("servant method 'temperatureChanged' not implemented")

        def getTemperature(self, current=None):
            raise NotImplementedError("servant method 'getTemperature' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_TemperatureSensorDisp)

        __repr__ = __str__

    _M_SmartHouse._t_TemperatureSensorDisp = IcePy.defineClass('::SmartHouse::TemperatureSensor', TemperatureSensor, (), None, (_M_SmartHouse._t_SensorDisp,))
    TemperatureSensor._ice_type = _M_SmartHouse._t_TemperatureSensorDisp

    TemperatureSensor._op_temperatureChanged = IcePy.Operation('temperatureChanged', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0),), (), None, (_M_SmartHouse._t_TemperatureSensorException,))
    TemperatureSensor._op_getTemperature = IcePy.Operation('getTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_double, False, 0), ())

    _M_SmartHouse.TemperatureSensor = TemperatureSensor
    del TemperatureSensor

if 'DoorSensorException' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.DoorSensorException = Ice.createTempClass()
    class DoorSensorException(Ice.UserException):
        def __init__(self, errorTime=Ice._struct_marker, reason=''):
            if errorTime is Ice._struct_marker:
                self.errorTime = _M_SmartHouse.TimeOfDay()
            else:
                self.errorTime = errorTime
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::DoorSensorException'

    _M_SmartHouse._t_DoorSensorException = IcePy.defineException('::SmartHouse::DoorSensorException', DoorSensorException, (), False, None, (
        ('errorTime', (), _M_SmartHouse._t_TimeOfDay, False, 0),
        ('reason', (), IcePy._t_string, False, 0)
    ))
    DoorSensorException._ice_type = _M_SmartHouse._t_DoorSensorException

    _M_SmartHouse.DoorSensorException = DoorSensorException
    del DoorSensorException

_M_SmartHouse._t_DoorSensor = IcePy.defineValue('::SmartHouse::DoorSensor', Ice.Value, -1, (), False, True, None, ())

if 'DoorSensorPrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.DoorSensorPrx = Ice.createTempClass()
    class DoorSensorPrx(_M_SmartHouse.SensorPrx):

        def isOpen(self, context=None):
            return _M_SmartHouse.DoorSensor._op_isOpen.invoke(self, ((), context))

        def isOpenAsync(self, context=None):
            return _M_SmartHouse.DoorSensor._op_isOpen.invokeAsync(self, ((), context))

        def begin_isOpen(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.DoorSensor._op_isOpen.begin(self, ((), _response, _ex, _sent, context))

        def end_isOpen(self, _r):
            return _M_SmartHouse.DoorSensor._op_isOpen.end(self, _r)

        def doorOpened(self, context=None):
            return _M_SmartHouse.DoorSensor._op_doorOpened.invoke(self, ((), context))

        def doorOpenedAsync(self, context=None):
            return _M_SmartHouse.DoorSensor._op_doorOpened.invokeAsync(self, ((), context))

        def begin_doorOpened(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.DoorSensor._op_doorOpened.begin(self, ((), _response, _ex, _sent, context))

        def end_doorOpened(self, _r):
            return _M_SmartHouse.DoorSensor._op_doorOpened.end(self, _r)

        def doorClosed(self, context=None):
            return _M_SmartHouse.DoorSensor._op_doorClosed.invoke(self, ((), context))

        def doorClosedAsync(self, context=None):
            return _M_SmartHouse.DoorSensor._op_doorClosed.invokeAsync(self, ((), context))

        def begin_doorClosed(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.DoorSensor._op_doorClosed.begin(self, ((), _response, _ex, _sent, context))

        def end_doorClosed(self, _r):
            return _M_SmartHouse.DoorSensor._op_doorClosed.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.DoorSensorPrx.ice_checkedCast(proxy, '::SmartHouse::DoorSensor', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.DoorSensorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::DoorSensor'
    _M_SmartHouse._t_DoorSensorPrx = IcePy.defineProxy('::SmartHouse::DoorSensor', DoorSensorPrx)

    _M_SmartHouse.DoorSensorPrx = DoorSensorPrx
    del DoorSensorPrx

    _M_SmartHouse.DoorSensor = Ice.createTempClass()
    class DoorSensor(_M_SmartHouse.Sensor):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::DoorSensor', '::SmartHouse::Sensor')

        def ice_id(self, current=None):
            return '::SmartHouse::DoorSensor'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::DoorSensor'

        def isOpen(self, current=None):
            raise NotImplementedError("servant method 'isOpen' not implemented")

        def doorOpened(self, current=None):
            raise NotImplementedError("servant method 'doorOpened' not implemented")

        def doorClosed(self, current=None):
            raise NotImplementedError("servant method 'doorClosed' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_DoorSensorDisp)

        __repr__ = __str__

    _M_SmartHouse._t_DoorSensorDisp = IcePy.defineClass('::SmartHouse::DoorSensor', DoorSensor, (), None, (_M_SmartHouse._t_SensorDisp,))
    DoorSensor._ice_type = _M_SmartHouse._t_DoorSensorDisp

    DoorSensor._op_isOpen = IcePy.Operation('isOpen', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), ())
    DoorSensor._op_doorOpened = IcePy.Operation('doorOpened', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHouse._t_DoorSensorException,))
    DoorSensor._op_doorClosed = IcePy.Operation('doorClosed', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHouse._t_DoorSensorException,))

    _M_SmartHouse.DoorSensor = DoorSensor
    del DoorSensor

_M_SmartHouse._t_NormalDoorSensor = IcePy.defineValue('::SmartHouse::NormalDoorSensor', Ice.Value, -1, (), False, True, None, ())

if 'NormalDoorSensorPrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.NormalDoorSensorPrx = Ice.createTempClass()
    class NormalDoorSensorPrx(_M_SmartHouse.DoorSensorPrx):

        def isLocked(self, context=None):
            return _M_SmartHouse.NormalDoorSensor._op_isLocked.invoke(self, ((), context))

        def isLockedAsync(self, context=None):
            return _M_SmartHouse.NormalDoorSensor._op_isLocked.invokeAsync(self, ((), context))

        def begin_isLocked(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.NormalDoorSensor._op_isLocked.begin(self, ((), _response, _ex, _sent, context))

        def end_isLocked(self, _r):
            return _M_SmartHouse.NormalDoorSensor._op_isLocked.end(self, _r)

        def lockDoor(self, context=None):
            return _M_SmartHouse.NormalDoorSensor._op_lockDoor.invoke(self, ((), context))

        def lockDoorAsync(self, context=None):
            return _M_SmartHouse.NormalDoorSensor._op_lockDoor.invokeAsync(self, ((), context))

        def begin_lockDoor(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.NormalDoorSensor._op_lockDoor.begin(self, ((), _response, _ex, _sent, context))

        def end_lockDoor(self, _r):
            return _M_SmartHouse.NormalDoorSensor._op_lockDoor.end(self, _r)

        def unlockDoor(self, context=None):
            return _M_SmartHouse.NormalDoorSensor._op_unlockDoor.invoke(self, ((), context))

        def unlockDoorAsync(self, context=None):
            return _M_SmartHouse.NormalDoorSensor._op_unlockDoor.invokeAsync(self, ((), context))

        def begin_unlockDoor(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.NormalDoorSensor._op_unlockDoor.begin(self, ((), _response, _ex, _sent, context))

        def end_unlockDoor(self, _r):
            return _M_SmartHouse.NormalDoorSensor._op_unlockDoor.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.NormalDoorSensorPrx.ice_checkedCast(proxy, '::SmartHouse::NormalDoorSensor', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.NormalDoorSensorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::NormalDoorSensor'
    _M_SmartHouse._t_NormalDoorSensorPrx = IcePy.defineProxy('::SmartHouse::NormalDoorSensor', NormalDoorSensorPrx)

    _M_SmartHouse.NormalDoorSensorPrx = NormalDoorSensorPrx
    del NormalDoorSensorPrx

    _M_SmartHouse.NormalDoorSensor = Ice.createTempClass()
    class NormalDoorSensor(_M_SmartHouse.DoorSensor):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::DoorSensor', '::SmartHouse::NormalDoorSensor', '::SmartHouse::Sensor')

        def ice_id(self, current=None):
            return '::SmartHouse::NormalDoorSensor'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::NormalDoorSensor'

        def isLocked(self, current=None):
            raise NotImplementedError("servant method 'isLocked' not implemented")

        def lockDoor(self, current=None):
            raise NotImplementedError("servant method 'lockDoor' not implemented")

        def unlockDoor(self, current=None):
            raise NotImplementedError("servant method 'unlockDoor' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_NormalDoorSensorDisp)

        __repr__ = __str__

    _M_SmartHouse._t_NormalDoorSensorDisp = IcePy.defineClass('::SmartHouse::NormalDoorSensor', NormalDoorSensor, (), None, (_M_SmartHouse._t_DoorSensorDisp,))
    NormalDoorSensor._ice_type = _M_SmartHouse._t_NormalDoorSensorDisp

    NormalDoorSensor._op_isLocked = IcePy.Operation('isLocked', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), ())
    NormalDoorSensor._op_lockDoor = IcePy.Operation('lockDoor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHouse._t_DoorSensorException,))
    NormalDoorSensor._op_unlockDoor = IcePy.Operation('unlockDoor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHouse._t_DoorSensorException,))

    _M_SmartHouse.NormalDoorSensor = NormalDoorSensor
    del NormalDoorSensor

_M_SmartHouse._t_GarageDoorSensor = IcePy.defineValue('::SmartHouse::GarageDoorSensor', Ice.Value, -1, (), False, True, None, ())

if 'GarageDoorSensorPrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.GarageDoorSensorPrx = Ice.createTempClass()
    class GarageDoorSensorPrx(_M_SmartHouse.DoorSensorPrx):

        def openGarageDoor(self, context=None):
            return _M_SmartHouse.GarageDoorSensor._op_openGarageDoor.invoke(self, ((), context))

        def openGarageDoorAsync(self, context=None):
            return _M_SmartHouse.GarageDoorSensor._op_openGarageDoor.invokeAsync(self, ((), context))

        def begin_openGarageDoor(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.GarageDoorSensor._op_openGarageDoor.begin(self, ((), _response, _ex, _sent, context))

        def end_openGarageDoor(self, _r):
            return _M_SmartHouse.GarageDoorSensor._op_openGarageDoor.end(self, _r)

        def closeGarageDoor(self, context=None):
            return _M_SmartHouse.GarageDoorSensor._op_closeGarageDoor.invoke(self, ((), context))

        def closeGarageDoorAsync(self, context=None):
            return _M_SmartHouse.GarageDoorSensor._op_closeGarageDoor.invokeAsync(self, ((), context))

        def begin_closeGarageDoor(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.GarageDoorSensor._op_closeGarageDoor.begin(self, ((), _response, _ex, _sent, context))

        def end_closeGarageDoor(self, _r):
            return _M_SmartHouse.GarageDoorSensor._op_closeGarageDoor.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.GarageDoorSensorPrx.ice_checkedCast(proxy, '::SmartHouse::GarageDoorSensor', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.GarageDoorSensorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::GarageDoorSensor'
    _M_SmartHouse._t_GarageDoorSensorPrx = IcePy.defineProxy('::SmartHouse::GarageDoorSensor', GarageDoorSensorPrx)

    _M_SmartHouse.GarageDoorSensorPrx = GarageDoorSensorPrx
    del GarageDoorSensorPrx

    _M_SmartHouse.GarageDoorSensor = Ice.createTempClass()
    class GarageDoorSensor(_M_SmartHouse.DoorSensor):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::DoorSensor', '::SmartHouse::GarageDoorSensor', '::SmartHouse::Sensor')

        def ice_id(self, current=None):
            return '::SmartHouse::GarageDoorSensor'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::GarageDoorSensor'

        def openGarageDoor(self, current=None):
            raise NotImplementedError("servant method 'openGarageDoor' not implemented")

        def closeGarageDoor(self, current=None):
            raise NotImplementedError("servant method 'closeGarageDoor' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_GarageDoorSensorDisp)

        __repr__ = __str__

    _M_SmartHouse._t_GarageDoorSensorDisp = IcePy.defineClass('::SmartHouse::GarageDoorSensor', GarageDoorSensor, (), None, (_M_SmartHouse._t_DoorSensorDisp,))
    GarageDoorSensor._ice_type = _M_SmartHouse._t_GarageDoorSensorDisp

    GarageDoorSensor._op_openGarageDoor = IcePy.Operation('openGarageDoor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHouse._t_DoorSensorException,))
    GarageDoorSensor._op_closeGarageDoor = IcePy.Operation('closeGarageDoor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHouse._t_DoorSensorException,))

    _M_SmartHouse.GarageDoorSensor = GarageDoorSensor
    del GarageDoorSensor

# End of module SmartHouse
